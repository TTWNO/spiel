//! # D-Bus interface proxy for: `org.freedesktop.Speech.Provider`
//!
//! This code was generated by `zbus-xmlgen` `4.0.1` from D-Bus introspection data.
//! Source: `org.freedesktop.Speech.Provider.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,

use enumflags2::{bitflags, BitFlags};
use zbus::proxy;

/// An individual voice feature.
///
/// Knowledge of [Speech Synthesis Markup Language
/// (SSML)](https://www.w3.org/TR/speech-synthesis11/) may be useful.
#[bitflags]
#[derive(
	Copy,
	Clone,
	Debug,
	serde_repr::Serialize_repr,
	serde_repr::Deserialize_repr,
	Type,
	PartialEq,
	Eq,
)]
#[repr(u64)]
pub enum VoiceFeature {
	/// Send [`crate::Event`] when starting/ending the speech within a word.
	EventsWord,
	/// Send [`crate::Event`] when starting/ending the speech within a sentence.
	EventsSentence,
	/// Send [`crate::Event`] when starting/ending the speech within a given range.
	EventsRange,
	/// Send [`crate::Event`] when starting/ending the speech between an SSML `<mark>` tag.
	EventsSSMLMark,
	/// Will interpret `<say-as interpret-as="date">`
	SSMLSayAsDate,
	/// Will interpret `<say-as interpret-as="time">`
	SSMLSayAsTime,
	/// Will interpret `<say-as interpret-as="telephone">`
	SSMLSayAsTelephone,
	/// Will interpret `<say-as interpret-as="characters">` (or similar variant)
	SSMLSayAsCharacters,
	/// Will interpret `<say-as interpret-as="characters-glyphs">` (or similar variant)
	SSMLSayAsCharactersGlyphs,
	/// Will interpret `<say-as interpret-as="number" format="cardinal">` (or similar variant)
	SSMLSayAsCaridnal,
	/// Will interpret `<say-as interpret-as="number" format="currency">` (or similar variant)
	SSMLSayAsCurrency,
	/// Will interpret SSML [`<break .../>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_break)
	SSMLBreak,
	/// Will interpret SSML [`<sub>...</sub>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_sub)
	SSMLSub,
	/// Will interpret SSML [`<phoneme>...</phoneme>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_phoneme)
	SSMLPhoneme,
	/// Will interpret SSML [`<emphasis>...</emphasis>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_emphasis)
	SSMLEmphasis,
	/// Will interpret SSML [`<prosody>...</prosody>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_prosody)
	SSMLProsidy,
	/// Will interpret SSML [`<p>...</p>` and `<s>...</s>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_paragraph)
	SSMLSentenceParagraph,
	/// Will interpret SSML [`<token>...</token>` commands](https://www.w3.org/TR/speech-synthesis11/#edef_token)
	SSMLToken,
}

use zbus::zvariant::{Type, Value};

#[derive(Copy, Clone, Debug, PartialEq, Eq, Type, serde::Serialize, serde::Deserialize)]
#[repr(transparent)]
#[serde(transparent)]
pub struct VoiceFeatureSet(BitFlags<VoiceFeature>);

impl VoiceFeatureSet {
	#[must_use]
	pub fn empty() -> Self {
		VoiceFeatureSet(BitFlags::<VoiceFeature>::EMPTY)
	}
}

impl TryFrom<Value<'_>> for VoiceFeatureSet {
	type Error = zbus::zvariant::Error;
	fn try_from(zv: Value<'_>) -> Result<Self, Self::Error> {
		Ok(VoiceFeatureSet(BitFlags::from_bits_truncate(TryInto::<u64>::try_into(zv)?)))
	}
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, Type, PartialEq, Eq)]
#[serde(transparent)]
#[repr(transparent)]
pub struct VoiceList(Vec<Voice>);

/// All the information about a voice, including its audio output format, capabilities, and a
/// string-based unique ID in order to reference it.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, Type, PartialEq, Eq)]
#[zvariant(signature = "ssstas")]
pub struct Voice {
	/// A human-readable name.
	pub name: String,
	/// A unique identifier for calling [`ProviderProxy::synthesize`].
	pub id: String,
	/// A MIME followed by audio format information in GStreamer-Caps style, e.g.:
	///
	/// - `audio/x-raw,format=S32LE,channels=2,rate=22050`
	///     - Format: PCM, signed 32-bit little-endian
	///     - Channels: 2
	///     - Sample rate: 22050
	/// - `audio/x-spiel,format=S16LE,channels=1,rate=22050`
	///     - Format: [Spiel (mixed audio/events)](`crate::Message`) signed 16-bit little-endian
	///     - Channels: 1
	///     - Sample rate: 22050
	///
	/// It is up to the caller to determine what to do with this string.
	pub mime_format: String,
	/// Bitflag of [`VoiceFeature`].
	pub features: VoiceFeatureSet,
	/// A list of BCP 47 tags.
	pub languages: Vec<String>,
}

impl TryFrom<Value<'_>> for Voice {
	type Error = zbus::zvariant::Error;
	fn try_from(zv: Value<'_>) -> Result<Self, Self::Error> {
		let (name, id, mime_format, features, languages) = zv.try_into()?;
		Ok(Voice { name, id, mime_format, features, languages })
	}
}
impl From<Voice> for Value<'_> {
	fn from(voice: Voice) -> Self {
		let Voice { name, id, mime_format, features, languages } = voice;
		(name, id, mime_format, features.0.bits(), languages).into()
	}
}

#[proxy(interface = "org.freedesktop.Speech.Provider")]
pub trait Provider {
	/// Synthesize method
	#[allow(clippy::too_many_arguments)]
	fn synthesize(
		&self,
		pipe_fd: zbus::zvariant::Fd<'_>,
		text: &str,
		voice_id: &str,
		pitch: f64,
		rate: f64,
		is_ssml: bool,
		language: &str,
	) -> zbus::Result<()>;

	/// Name property
	#[zbus(property)]
	fn name(&self) -> zbus::Result<String>;

	/// Voices property
	#[zbus(property)]
	fn voices(&self) -> zbus::Result<Vec<Voice>>;
}

#[test]
fn serialize_deserialize_dbus() {
	use zbus::zvariant::{serialized::Context, to_bytes, LE};
	let voice = Voice {
		name: "eSpeak".to_string(),
		id: "espeak-ng".to_string(),
		mime_format: "audio/x-raw,format=S16LE,channels=1,rate=11520".to_string(),
		languages: vec!["en-GB".to_string(), "en-US".to_string(), "zh-TW".to_string()],
		features: VoiceFeatureSet(VoiceFeature::EventsWord | VoiceFeature::SSMLSub),
	};
	let ctxt = Context::new_dbus(LE, 0);
	let encoded = to_bytes(ctxt, &voice).unwrap();
	let (voice2, _decoded) = encoded.deserialize::<Voice>().unwrap();
	assert_eq!(voice, voice2);
}

use zbus::{fdo::DBusProxy, Connection};

pub struct Client<'a> {
	con: Connection,
	fdo: DBusProxy<'a>,
}

impl Client<'_> {
	/// Create a new Spiel client.
	///
	/// # Errors
	///
	/// Anything that causes the `DBus` connection to fail will be returned as an error.
	/// You need an active session in order to complete this.
	pub async fn new() -> Result<Self, zbus::Error> {
		let con = Connection::session().await?;
		let fdo = DBusProxy::new(&con).await?;
		Ok(Client { con, fdo })
	}
	/// Get a list of speech providers.
	///
	/// # Errors
	///
	/// Any error that causes `DBus` to either be:
	///
	/// 1. Unable to query the session for activatable names, or
	/// 2. Stops the creation of proxies pointing to a name ending in `Speech.Provider`.
	pub async fn list_providers(&self) -> Result<Vec<ProviderProxy<'_>>, zbus::Error> {
		let names =
			self.fdo.list_names()
				.await?
				.into_iter()
				.inspect(|name| println!("{name:?}"))
				.filter(|name| name.ends_with("Speech.Provider"));
		let mut providers = Vec::new();
		for name in names {
			let proxy = ProviderProxy::new(
				&self.con,
				name.clone(),
				format!("/{}", name.as_str().replace('.', "/")),
			)
			.await?;
			providers.push(proxy);
		}
		Ok(providers)
	}
}
